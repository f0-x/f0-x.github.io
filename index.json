[{"categories":["frontend","UI"],"content":"In this article, I‚Äôll share some best practices for working with Tailwind CSS, which I usually prefer to follow and have learnt over a period of time. By following these tips, you can keep your application clean, organized, and maintainable, even as your project grows. ","date":"2024-04-23","objectID":"/posts/tailwind-best-practises/:0:0","tags":["tailwind","reactjs"],"title":"How to TailWind CSS like a Pro","uri":"/posts/tailwind-best-practises/"},{"categories":["frontend","UI"],"content":"1. Utilize Design Tokens ü™ô Design tokens are like special containers that hold all the important things that make your designs look good, like colors, sizes, fonts, and where things break on a screen. They help you make sure everything looks the same across all your designs and makes it easy to change things later on. In the tailwind.config.js file, you can create special codes called design tokens. It‚Äôs a smart way to keep all your design codes in one place so that all your special designs can be used by all your different class names in Tailwind CSS. Tailwind Built-in Color Palette Ensure that you assign meaningful semantic names to all the colors used in your project, replacing or extending the default color palette. For multi-theme support, opt to define your colors as CSS variables instead of within your Tailwind configuration. This approach enables you to associate multiple colors with the same semantic name, depending on the selected theme. //\u003c!-- tailwind.config.js --\u003e import defaultTheme from \"tailwindcss/defaultTheme\"; const config = { content: [ \"./src/**/*.{js,ts,jsx,tsx,mdx}\", ], theme: { extend: { fontFamily: { manrope: \"var(--font-manrope)\", }, colors: { ...defaultTheme.colors, theme: \"#7743DB\", light: { primary: \"#FFFFFF\", secondary: \"#f1f1ef\", }, dark: { primary: \"#0F0F0F\", secondary: \"#202020\", }, \"background\": \"#F5F5F5\", }, screens: { ...defaultTheme.screens, xs: \"340px\", sm: \"420px\", }, spacing: { spacing: { ...defaultTheme.spacing, 1: '5px', 2: '10px', 3: '15px', 4: '20px', 5: '25px' } } }, }, }; export default config; ","date":"2024-04-23","objectID":"/posts/tailwind-best-practises/:1:0","tags":["tailwind","reactjs"],"title":"How to TailWind CSS like a Pro","uri":"/posts/tailwind-best-practises/"},{"categories":["frontend","UI"],"content":"2. Make styles reusable üé® Tailwind works best with React, Vue, or Svelte because it helps make components easier to use and reuse. It can still be used with regular HTML, but it might lead to a lot of repeated code. The Tailwind Docs suggest using a special editing technique to avoid this, but it can be tricky and you have to be careful to select all the right parts. With a component-based framework like React, you can create a part of your website once and use it many times in different places. // Define a reusable Button component using Tailwind utility classes const Button = ({ children, onClick }) =\u003e { return ( \u003cbutton onClick={onClick} className=\"bg-primary hover:bg-primary-alt text-primary-contrast py-2 px-4 rounded\" \u003e {children} \u003c/button\u003e ); }; // Use (and re-use) the Button component without having to duplicate Tailwind classes const App = () =\u003e { return ( \u003cdiv\u003e \u003cButton onClick={() =\u003e console.log('Clicked!')}\u003eClick Me\u003c/Button\u003e \u003cButton onClick={() =\u003e console.log('Clicked too!')}\u003eClick Me Too\u003c/Button\u003e \u003c/div\u003e ); }; ","date":"2024-04-23","objectID":"/posts/tailwind-best-practises/:2:0","tags":["tailwind","reactjs"],"title":"How to TailWind CSS like a Pro","uri":"/posts/tailwind-best-practises/"},{"categories":["frontend","UI"],"content":"3. Use arbitrary values rarely üôÖ‚Äç‚ôÄÔ∏è Consider a web application that adheres to a specific color scheme. For instance, we‚Äôve chosen #7743DB as our theme color and #0D0D0D as our background color. To maintain consistency and improve readability, we can add these colors to our Tailwind CSS configuration. Instead of using arbitrary values directly in our HTML or CSS, we‚Äôll create semantic class names. For example: bg-background for the background color text-theme for the theme color //\u003c!-- tailwind.config.js --\u003e import defaultTheme from \"tailwindcss/defaultTheme\"; const config = { content: [ \"./src/**/*.{js,ts,jsx,tsx,mdx}\", ], theme: { extend: { colors: { ...defaultTheme.colors, theme: \"#7743DB\", background: \"#0D0D0D\" }, }, }, }; export default config; Now, if we decide to change our application‚Äôs color scheme, we only need to update the tailwind.config.js file. This approach avoids the hassle of renaming arbitrary class names scattered throughout our codebase. ","date":"2024-04-23","objectID":"/posts/tailwind-best-practises/:3:0","tags":["tailwind","reactjs"],"title":"How to TailWind CSS like a Pro","uri":"/posts/tailwind-best-practises/"},{"categories":["frontend","UI"],"content":"4. Handle dynamic classes with care üßê You all might have encountered this issue while working with dynamic classes that whenever we apply some dynamic class name based on state or some condition, the class name appears in elements panel on the browser, but its corresponding CSS does not. This is because Tailwind scans your source code for classes using regular expressions to extract every string that could possibly be a class name. He nce, any broken class name string such as border-[${borderColor}] would not be recognised by tailwind at build time, and it would not be included in the output CSS file of tailwind. Suppose, we have to change the border colour of our element based on the colour code passed in props. There are two ways to it: Defining a separate class name for each state value. This is only applicable if you know all the expected values of the borderColor at build time. Note: clsx is utility package for constructing className strings conditionally. //\u003c!-- BorderBox.jsx --\u003e const BorderBox = ({ borderColor }) =\u003e { return ( \u003cdiv className={clsx(\"border border-solid\", { \"border-black\": borderColor === \"black\", \"border-red-500\": borderColor === \"red\", \"border-green-500\": borderColor === \"green\", })} \u003e Some Random Text \u003c/div\u003e ); }; 2. If we do not know all the expected value of borderColor at build time, it is better to pass the border colour in the style attribute of the element to support unknown values. //\u003c!-- BorderBox.jsx --\u003e const BorderBox = ({ borderColor }) =\u003e { return ( \u003cdiv className=\"border border-solid\" style={{ borderColor }}\u003e Some Random Text \u003c/div\u003e ); }; ","date":"2024-04-23","objectID":"/posts/tailwind-best-practises/:4:0","tags":["tailwind","reactjs"],"title":"How to TailWind CSS like a Pro","uri":"/posts/tailwind-best-practises/"},{"categories":["frontend","UI"],"content":"5. Accessing CSS design tokens in JavaScript üß≤ In Web applications, there are multiple scenarios where you need to access a CSS design token value in JavaScript. When such situations arise, developers often hardcode the CSS design token directly into their code while working with Tailwind CSS. However, this practice is not ideal. If you later modify the design token value in your Tailwind configuration, your code might still reference the old value, potentially leading to unintended behavior. To address this, consider creating a custom utility function that reads the Tailwind configuration dynamically within your codebase. //\u003c!-- tailwind.config.js --\u003e import resolveConfig from \"tailwindcss/resolveConfig\"; import tailwindConfig from \"../tailwind.config\"; const getTailwindConfiguration = () =\u003e { return resolveConfig(tailwindConfig).theme; }; const config = getTailwindConfiguration(); console.log(config.colors.red[500]); // would print #ef4444 ","date":"2024-04-23","objectID":"/posts/tailwind-best-practises/:5:0","tags":["tailwind","reactjs"],"title":"How to TailWind CSS like a Pro","uri":"/posts/tailwind-best-practises/"},{"categories":["frontend","UI"],"content":"6. Tailwind Plugins üß© Tailwind provides us with plugins to register new styles to inject into the user‚Äôs stylesheet using JavaScript instead of writing custom CSS styling in stylesheets. I find this approach better, as writing custom CSS classes means you‚Äôre essentially rewriting CSS and waving goodbye to Tailwind‚Äôs organized workflow and simple maintenance. Suppose we want to create a .header class which has several styles attached to it. This is how we can achieve it: //\u003c!-- tailwind.config.js --\u003e import plugin from \"tailwindcss/plugin\"; const config = { content: [ \"./src/**/*.{js,ts,jsx,tsx,mdx}\", ], plugins: [ plugin(function ({ addComponents }) { addComponents({ \".header\": { fontWeight: \"600\", height: \"3rem\", borderRadius: \".25rem\", backgroundColor: \"#f5f5f5\", boxShadow: \"0 2px 4px 0 rgba(0,0,0,.1)\", display: \"flex\", justifyContent: \"space-between\", alignItems: \"center\", \"\u0026:hover\": { backgroundColor: \"#f5f5f5\", }, }, }); }), ], }; export default config; This is how the .header class would look like when you hover over it: Custom Tailwind Plugin for Complex styles ","date":"2024-04-23","objectID":"/posts/tailwind-best-practises/:6:0","tags":["tailwind","reactjs"],"title":"How to TailWind CSS like a Pro","uri":"/posts/tailwind-best-practises/"},{"categories":["frontend","UI"],"content":"Final Words üé§ While Tailwind CSS provides a strong and versatile utility-first approach to styling web apps, it‚Äôs important to avoid common errors that can jeopardize the maintainability and scalability of your code. By carefully integrating Tailwind with a uniform design system, embracing component-based architecture, and establishing a library of reusable components, you can create clean, consistent, and highly maintainable user interfaces. ","date":"2024-04-23","objectID":"/posts/tailwind-best-practises/:7:0","tags":["tailwind","reactjs"],"title":"How to TailWind CSS like a Pro","uri":"/posts/tailwind-best-practises/"},{"categories":["UI","UX"],"content":"The Need for a Robust UI Component Library As our web application grew in complexity, we found ourselves constantly reinventing the wheel when it came to building user interfaces. Our development team was spending too much time creating and maintaining custom UI components, leading to inconsistent styles, duplicated code, and a suboptimal developer experience. To address these challenges, we decided to invest in building a comprehensive UI component library that would serve as the foundation for our application‚Äôs user interface. Our goal was to create a modular and scalable system that would not only improve the efficiency of our development process but also ensure a cohesive and visually appealing user experience. ","date":"2024-04-05","objectID":"/posts/ui-components/:1:0","tags":["tailwind","css","storybook","react"],"title":"Intuji UI Components ‚ôæÔ∏è","uri":"/posts/ui-components/"},{"categories":["UI","UX"],"content":"Embracing Tailwind CSS for Consistent Styling After careful consideration, we chose to build our component library using Tailwind CSS, a utility-first CSS framework that has gained immense popularity in the front-end development community. Tailwind CSS provides a vast collection of low-level utility classes that can be easily composed to create complex designs, allowing us to achieve a high degree of customization and consistency across our components. By leveraging Tailwind CSS, we were able to establish a robust design system that seamlessly integrates with our application‚Äôs branding and UI guidelines. The utility-first approach of Tailwind CSS empowers our developers to quickly prototype and iterate on component designs, without the need to write extensive custom CSS. ","date":"2024-04-05","objectID":"/posts/ui-components/:2:0","tags":["tailwind","css","storybook","react"],"title":"Intuji UI Components ‚ôæÔ∏è","uri":"/posts/ui-components/"},{"categories":["UI","UX"],"content":"Integrating TypeScript for Enhanced Developer Experience To ensure type safety and improve the overall developer experience, we decided to implement our component library using TypeScript. By embracing the static typing capabilities of TypeScript, we were able to catch potential errors during development, leading to more reliable and maintainable code. The TypeScript integration also allowed us to provide detailed type definitions for our components, making it easier for other developers to understand and use the library. This, in turn, helped to reduce the learning curve and improved the overall developer productivity within our team. ","date":"2024-04-05","objectID":"/posts/ui-components/:3:0","tags":["tailwind","css","storybook","react"],"title":"Intuji UI Components ‚ôæÔ∏è","uri":"/posts/ui-components/"},{"categories":["UI","UX"],"content":"Leveraging Storybook for Isolated Component Development To facilitate the development, documentation, and testing of our UI components, we integrated Storybook into our workflow. Storybook is a powerful tool that enables us to build UI components in isolation, without the interference of the actual application‚Äôs state or dependencies. By using Storybook, our developers can focus on creating and refining individual components, ensuring that they adhere to the design guidelines and are thoroughly tested. Additionally, Storybook‚Äôs rich feature set, including the ability to generate interactive documentation and facilitate visual regression testing, has been invaluable in streamlining our component development process. ","date":"2024-04-05","objectID":"/posts/ui-components/:4:0","tags":["tailwind","css","storybook","react"],"title":"Intuji UI Components ‚ôæÔ∏è","uri":"/posts/ui-components/"},{"categories":["UI","UX"],"content":"Ensuring Reliability with Vitest To maintain the quality and stability of our UI component library, we‚Äôve implemented a comprehensive testing suite using Vitest, a modern and lightning-fast testing framework. Vitest allows us to write unit tests for our components, ensuring that they behave as expected and continue to function correctly as the library evolves. The integration of Vitest has been instrumental in catching regressions early in the development cycle, reducing the risk of introducing breaking changes and ensuring a reliable user experience for our application‚Äôs end-users. ","date":"2024-04-05","objectID":"/posts/ui-components/:5:0","tags":["tailwind","css","storybook","react"],"title":"Intuji UI Components ‚ôæÔ∏è","uri":"/posts/ui-components/"},{"categories":["UI","UX"],"content":"Continuous Improvement and Expansion As we continue to build and maintain our UI component library, we‚Äôre committed to an iterative approach that prioritizes user feedback, emerging front-end trends, and the evolving needs of our application. We‚Äôll regularly review the library‚Äôs design, APIs, and documentation, making adjustments and additions as necessary to keep it up-to-date and aligned with the project‚Äôs requirements. By leveraging Tailwind CSS, TypeScript, Storybook, and Vitest, we‚Äôve laid a strong foundation for a scalable and maintainable UI component library that will empower our development team to build high-quality user interfaces more efficiently. We‚Äôre excited to see how this library will continue to evolve and support the growth of our application in the months and years to come. Final Words The Intuji UI component library is an ongoing project, and we‚Äôre committed to its continuous improvement and expansion. As our application‚Äôs needs evolve and as we gather feedback from our users, we‚Äôll be regularly updating and enhancing the library to ensure it remains a reliable and cutting-edge resource for our development team. This blog post itself will also be updated over time to reflect the latest developments, new features, and improvements made to the Intuji component library. Be sure to check back periodically for the most up-to-date information and insights. We‚Äôre excited to see how the Intuji library will continue to grow and support the success of our application. Thank you for your interest, and we look forward to sharing more updates with you in the future. Hyperlinks Github Repo: Intuji UI Components Documentation Site: Intuji UI Components ","date":"2024-04-05","objectID":"/posts/ui-components/:6:0","tags":["tailwind","css","storybook","react"],"title":"Intuji UI Components ‚ôæÔ∏è","uri":"/posts/ui-components/"},{"categories":["UI","UX"],"content":"Content loaders, skeleton screens, ghost elements, and content placeholders. These are the names given to the effect we‚Äôll be exploring today. Many companies, such as LinkedIn, Facebook, YouTube and Slack, use this effect in their apps and websites, as you may have noticed. As much as we developers want our websites to load as quickly as possible, there are times when a lot of data needs to be rendered on the page, so Skeleton screens are a great option. CSS technology used Although some of the above mentioned sites use Vanilla CSS and other CSS libs/frameworks to achieve the effect, I have used the latest version of Tailwind CSS (v3.1.5) as of date to create it. Developers earlier used to add a loading spinner animation to indicate that the page resources are still being fetched in the background which doesn‚Äôt fit the UI/UX standards of the current timeline. Classic Loading Spinner Animation This boring spinner animation would definitely result a lower score in User Experience Web Index. ","date":"2022-07-03","objectID":"/posts/tailwind-skeleton/:0:0","tags":["tailwind","css"],"title":"‚ú®Shiny Skeleton Animation using TailwindCSSüí®","uri":"/posts/tailwind-skeleton/"},{"categories":["UI","UX"],"content":" Animated skeleton example I grabbed from some random site ","date":"2022-07-03","objectID":"/posts/tailwind-skeleton/:1:0","tags":["tailwind","css"],"title":"‚ú®Shiny Skeleton Animation using TailwindCSSüí®","uri":"/posts/tailwind-skeleton/"},{"categories":["UI","UX"],"content":"Building a Skeleton Block ü¶¥ First of all, lets use Tailwind‚Äôs range of utility classes to create a skeleton that roughly resembles the content you‚Äôre about to load. I have created a simple block to denote a member of our skeleton animation which may(not) scale throughout the viewport. Size Limit For demonstration purposes I have limited the wrapper width to 200px. If you were to increase the dimension, you would have to update the CSS props accordingly. \u003cdiv class=\"flex min-h-screen items-center justify-center bg-gray-900\"\u003e \u003cdiv class=\"w-[200px]\"\u003e \u003cdiv class=\"space-y-5 rounded-2xl bg-white/5 p-4 shadow-xl shadow-black/5\"\u003e \u003cdiv class=\"h-24 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"space-y-3\"\u003e \u003cdiv class=\"h-3 w-3/5 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-4/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-2/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e ","date":"2022-07-03","objectID":"/posts/tailwind-skeleton/:2:0","tags":["tailwind","css"],"title":"‚ú®Shiny Skeleton Animation using TailwindCSSüí®","uri":"/posts/tailwind-skeleton/"},{"categories":["UI","UX"],"content":"Linear Gradient Overlay üåä I have to admit that I don‚Äôt cross paths often with Linear Gradients on my day-to-day work. However with enough effort I was able to use Tailwind‚Äôs gradient color stops to create a gradient that fades from transparent to white and back to transparent. \u003cdiv class=\"flex min-h-screen items-center justify-center bg-gray-900\"\u003e \u003cdiv class=\"w-[200px]\"\u003e \u003cdiv class=\"h-48 bg-gradient-to-r from-transparent via-rose-100/20 to-transparent\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e ","date":"2022-07-03","objectID":"/posts/tailwind-skeleton/:3:0","tags":["tailwind","css"],"title":"‚ú®Shiny Skeleton Animation using TailwindCSSüí®","uri":"/posts/tailwind-skeleton/"},{"categories":["UI","UX"],"content":"Keyframe Animation üé≠ Lets define a CSS keyframe animation that translates elements 100% to the right in the extend keyframes object of tailwind.config.js. I have used Tailwind‚Äôs arbitrary values to apply the keyframe animation to the overlay element. I have added a custom keyframe shift by the name of shimmer as well as curated my own color named stone from the Tailwind‚Äôs default color palette by importing tailwindcss/colors. tailwind.config.js const colors = require('tailwindcss/colors') module.exports = { theme: { extend: { colors: { gray: colors.stone, }, }, keyframes: { shimmer: { '100%': { transform: 'translateX(100%)', }, }, }, }, plugins: [], } \u003cdiv class=\"flex min-h-screen items-center justify-center bg-gray-900\"\u003e \u003cdiv class=\"w-[200px]\"\u003e \u003cdiv class=\"h-48 -translate-x-full animate-[shimmer_2s_infinite] bg-gradient-to-r from-transparent via-rose-100/20 to-transparent\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e ","date":"2022-07-03","objectID":"/posts/tailwind-skeleton/:4:0","tags":["tailwind","css"],"title":"‚ú®Shiny Skeleton Animation using TailwindCSSüí®","uri":"/posts/tailwind-skeleton/"},{"categories":["UI","UX"],"content":"Mixing the Elements ü•¢ Now we shall combine our skeleton block with the overlay animation by adding the overlay to a pseudo-element of the skeleton wrapper using Tailwind‚Äôs before: modifier. \u003cdiv class=\"flex min-h-screen items-center justify-center bg-gray-900\"\u003e \u003cdiv class=\"w-[200px]\"\u003e \u003cdiv class=\"relative space-y-5 rounded-2xl bg-white/5 p-4 shadow-xl shadow-black/5 before:absolute before:inset-0 before:-translate-x-full before:animate-[shimmer_2s_infinite] before:bg-gradient-to-r before:from-transparent before:via-rose-100/10 before:to-transparent\"\u003e \u003cdiv class=\"h-24 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"space-y-3\"\u003e \u003cdiv class=\"h-3 w-3/5 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-4/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-2/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e ","date":"2022-07-03","objectID":"/posts/tailwind-skeleton/:5:0","tags":["tailwind","css"],"title":"‚ú®Shiny Skeleton Animation using TailwindCSSüí®","uri":"/posts/tailwind-skeleton/"},{"categories":["UI","UX"],"content":"Finishing Touches üé® To make our overlay animation sharper I tried hiding the overlay while it‚Äôs positioned outside the skeleton. This limits the overlay overflow within the skeleton‚Äôs block and gives our effect a sharper look. Optional Add a white border to the top of the overlay to simulate light reflecting on the top of the skeleton. \u003cdiv class=\"flex min-h-screen items-center justify-center bg-gray-900\"\u003e \u003cdiv class=\"w-[200px]\"\u003e \u003cdiv class=\"relative space-y-5 overflow-hidden rounded-2xl bg-white/5 p-4 shadow-xl shadow-black/5 before:absolute before:inset-0 before:-translate-x-full before:animate-[shimmer_2s_infinite] before:border-t before:border-rose-100/10 before:bg-gradient-to-r before:from-transparent before:via-rose-100/10 before:to-transparent\"\u003e \u003cdiv class=\"h-24 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"space-y-3\"\u003e \u003cdiv class=\"h-3 w-3/5 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-4/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-2/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e ","date":"2022-07-03","objectID":"/posts/tailwind-skeleton/:6:0","tags":["tailwind","css"],"title":"‚ú®Shiny Skeleton Animation using TailwindCSSüí®","uri":"/posts/tailwind-skeleton/"},{"categories":["UI","UX"],"content":"Final Words üéô Therefore, using powerful Tailwind CSS‚Äôs utility classes, we can build a complex customized layout to place our animated skeleton such as grid, flexbox, etc. Below is a simple grid layout with our fancy skeleton boxes. Here is the link to the Live Tailwind Playground to play around with our final build. \u003cdiv class=\"flex min-h-screen items-center justify-center bg-gray-900\"\u003e \u003cdiv class=\"grid w-[600px] grid-cols-3 gap-6\"\u003e \u003c!-- First Card Begins Here --\u003e \u003cdiv class=\"relative space-y-5 overflow-hidden rounded-2xl bg-white/5 p-4 shadow-xl shadow-black/5 before:absolute before:inset-0 before:-translate-x-full before:animate-[shimmer_2s_infinite] before:border-t before:border-rose-100/10 before:bg-gradient-to-r before:from-transparent before:via-rose-100/10 before:to-transparent\"\u003e \u003cdiv class=\"h-24 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"space-y-3\"\u003e \u003cdiv class=\"h-3 w-3/5 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-4/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-2/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c!-- First Card Ends Here --\u003e \u003c!--Second Card Begins Here --\u003e \u003cdiv class=\"relative space-y-5 overflow-hidden rounded-2xl bg-white/5 p-4 shadow-xl shadow-black/5 before:absolute before:inset-0 before:-translate-x-full before:animate-[shimmer_2s_infinite] before:border-t before:border-rose-100/10 before:bg-gradient-to-r before:from-transparent before:via-rose-100/10 before:to-transparent\"\u003e \u003cdiv class=\"h-24 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"space-y-3\"\u003e \u003cdiv class=\"h-3 w-3/5 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-4/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-2/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c!-- Second Card Ends Here --\u003e \u003c!-- Third Card Begins Here --\u003e \u003cdiv class=\"relative space-y-5 overflow-hidden rounded-2xl bg-white/5 p-4 shadow-xl shadow-black/5 before:absolute before:inset-0 before:-translate-x-full before:animate-[shimmer_2s_infinite] before:border-t before:border-rose-100/10 before:bg-gradient-to-r before:from-transparent before:via-rose-100/10 before:to-transparent\"\u003e \u003cdiv class=\"h-24 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"space-y-3\"\u003e \u003cdiv class=\"h-3 w-3/5 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-4/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-2/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c!-- Third Card Ends Here --\u003e \u003c/div\u003e \u003c/div\u003e I hope you found this article useful and that it serves as a good starting point (not only for developers but also for Designers) for creating various skeleton loading screens. If you found this article insightful, do share it with your friends and network. Before you leave üìå Do check out some amazing skeleton loading packages I have found for React, Angular and Vue. Thanks for reading, and keep creating amazing UI with Tailwindüí®! ","date":"2022-07-03","objectID":"/posts/tailwind-skeleton/:7:0","tags":["tailwind","css"],"title":"‚ú®Shiny Skeleton Animation using TailwindCSSüí®","uri":"/posts/tailwind-skeleton/"}]
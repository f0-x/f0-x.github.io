[{"categories":["algorithms","frontend"],"content":"Javascript Map is a rarely used data structure, hence it is not as widely understood as it would first appear, also is not as little as it first appears. We will start off with some fundamentals in this post and gradually head towards explaining the Map‚Äôs function as well as certain situations in which it may be helpful. ","date":"2024-05-22","objectID":"/posts/js-map-vs-array/:0:0","tags":["reactjs","javascript","algorithms"],"title":"ES6 Maps are underrated!","uri":"/posts/js-map-vs-array/"},{"categories":["algorithms","frontend"],"content":"The Big ‚≠ï Notation Understanding Big O Notation is crucial for analyzing the efficiency and scalability of algorithms and data structures. It allows developers to assess how algorithms will perform as the size of the input data increases. The notation provides a standardized way to express the worst-case scenario of an algorithm‚Äôs runtime in relation to the size of the input. As developers, it‚Äôs essential to choose algorithms and data structures with favorable time complexities to ensure efficient performance, especially when dealing with large datasets. When considering all this data, it becomes apparent that it‚Äôs best for the methods we use not to be dependent on the size of ‚Äôn‚Äô data. While these operations may be fast enough to go unnoticed individually, combining multiple operations simultaneously or nested loops can significantly degrade the user experience. Big O Analogy Imagine you‚Äôre a chef. Big O Notation is like a recipe that tells you how much more time you‚Äôll need if you decide to cook for a banquet instead of a family dinner. It‚Äôs a way to measure the ‚Äúheaviness‚Äù of a recipe. Just like you‚Äôd want a dish that can be scaled up easily for a large crowd, in programming, you want algorithms that can handle growing amounts of data gracefully. So, Big O is like a heads-up: ‚ÄúHey, this recipe might take a bit longer if you add more guests,‚Äù ","date":"2024-05-22","objectID":"/posts/js-map-vs-array/:1:0","tags":["reactjs","javascript","algorithms"],"title":"ES6 Maps are underrated!","uri":"/posts/js-map-vs-array/"},{"categories":["algorithms","frontend"],"content":"Array.prototype.find() üîç The find() method in JavaScript performs a linear search on an array. It returns the first element that satisfies the given condition, and it reads through all the data until it finds that element. Therefore, considering the worst-case scenario, where the item we are searching for is the last element of the array, we say it has a time complexity of O(n). This situation is exemplified in Aditya Bhargava‚Äôs book Grokking Algorithms as follows: Linear Search The Library of Hashes You‚Äôre in a huge library filled with books, and you‚Äôre tasked with finding specific information. Without a system, you‚Äôd have to look through each book one by one, which is time-consuming and inefficient, especially if the library keeps getting more books. Now, imagine you have a magical index that instantly points you to the exact location of the information you need, no matter how many books are in the library. This magical index is like a hash map in programming. It doesn‚Äôt matter if you have 10 books or 10,000; the magical index (hash map) helps you find your information quickly every time, which is why we say it has a time complexity of O(1)‚Äîit‚Äôs always fast, regardless of the size of the library (or data). üìö‚ú® ","date":"2024-05-22","objectID":"/posts/js-map-vs-array/:2:0","tags":["reactjs","javascript","algorithms"],"title":"ES6 Maps are underrated!","uri":"/posts/js-map-vs-array/"},{"categories":["algorithms","frontend"],"content":"Hash Map üó∫Ô∏è A hash map is essentially a storage that can map keys to their corresponding values. When you provide it with a key, it returns the value associated with that key, and you can perform insertion and deletion operations using the same key value in these hash tables. So, it‚Äôs a very fast storage system and requires O(1) time complexity for all these operations. Hash Map Nevertheless, there are certain considerations to keep in mind. For instance, if keys are distributed using an inefficient hash function, collisions may occur, complicating search operations. Additionally, maintaining a hash table with a fill rate exceeding approximately 70% can result in performance degradation. ","date":"2024-05-22","objectID":"/posts/js-map-vs-array/:3:0","tags":["reactjs","javascript","algorithms"],"title":"ES6 Maps are underrated!","uri":"/posts/js-map-vs-array/"},{"categories":["algorithms","frontend"],"content":"Map \u003e Array ? ü§î In recent projects, the find() method is commonly used within user interactive components. For instance, when we need to retrieve data based on parameters from dynamic routes, manipulate specific data, or fetch information selected from dropdowns or input fields, methods like find (and occasionally filter) come into play. These operations follow a linear approach and have a time complexity of O(n). Now, let‚Äôs explore how a Map can simplify accomplishing these tasks. const data = [ ... { \"age\": 50, \"email\": \"atuny@@sohu.com\", \"firstName\": \"Terry\", \"lastName\": \"Medhurst\", \"gender\": \"male\", \"id\": 1, \"username\": \"atunyo\", }, { \"age\": 28, \"email\": \"hbingleyl@plala.or.jp\", \"firstName\": \"Sheldon\", \"lastName\": \"Quigley\", \"gender\": \"male\", \"id\": 2, \"username\": \"hbingley1\", } ... ] ","date":"2024-05-22","objectID":"/posts/js-map-vs-array/:4:0","tags":["reactjs","javascript","algorithms"],"title":"ES6 Maps are underrated!","uri":"/posts/js-map-vs-array/"},{"categories":["algorithms","frontend"],"content":"What is a Map? üî¶ The Map in JavaScript provides a data structure for mapping keys to values. Unlike arrays, which are indexed by a range of numbers, maps can use any value as a key. This flexibility makes maps useful in various scenarios, especially when dealing with complex data structures or when quick access to data is required. let hashData = null; const getUsers = async () =\u003e { try { const response = await fetch(\"https://dummyjson.com/users\"); const data = await response.json(); hashData = new Map(data.users.map((user) =\u003e [user.username, user])); } catch (error) { console.error(\"Oops:\", error); } }; To convert our data into a Map using this method and to ensure that our keys are unique, we need to iterate over our data once. The only point we need to pay attention to is that our keys must be unique. Then we have the following result; Map(30) { atuny0 ‚Üí {‚Ä¶}, hbingley1 ‚Üí {‚Ä¶}, rshawe2 ‚Üí {‚Ä¶}, yraigatt3 ‚Üí {‚Ä¶}, kmeus4 ‚Üí {‚Ä¶}, jtreleven5 ‚Üí {‚Ä¶}, dpettegre6 ‚Üí {‚Ä¶}, ggude7 ‚Üí {‚Ä¶}, nloiterton8 ‚Üí {‚Ä¶}, umcgourty9 ‚Üí {‚Ä¶}, ‚Ä¶ } size: 30 \u003centries\u003e 0: atuny0 ‚Üí Object { id: 1, firstName: \"Terry\", lastName: \"Medhurst\", ‚Ä¶ } 1: hbingley1 ‚Üí Object { id: 2, firstName: \"Sheldon\", lastName: \"Quigley\", ‚Ä¶ } 2: rshawe2 ‚Üí Object { id: 3, firstName: \"Terrill\", lastName: \"Hills\", ‚Ä¶ } 3: yraigatt3 ‚Üí Object { id: 4, firstName: \"Miles\", lastName: \"Cummerata\", ‚Ä¶ } 4: kmeus4 ‚Üí Object { id: 5, firstName: \"Mavis\", lastName: \"Schultz\", ‚Ä¶ } 5: jtreleven5 ‚Üí Object { id: 6, firstName: \"Alison\", lastName: \"Reichert\", ‚Ä¶ } 6: dpettegre6 ‚Üí Object { id: 7, firstName: \"Oleta\", lastName: \"Abbott\", ‚Ä¶ } \u003cprototype\u003e: Map.prototype { ‚Ä¶ } This way, instead of using find, we can access the value associated with a key in our Map data structure using get with a time complexity of O(1), independent of the size of the data. Moreover, using the has method, we can check for the existence of that data with a time complexity of O(1) instead of using includes with a time complexity of O(n). Keys are case-sensitive, which provides us with convenience. JavaScript Maps are super underrated. Keys of a map can be anything - including an object! Here I'm using the new groupBy proposed API to group array items into a Map or an Object ‚Üí pic.twitter.com/RirGlB5akF ‚Äî Wes Bos (@wesbos) August 31, 2023 ","date":"2024-05-22","objectID":"/posts/js-map-vs-array/:5:0","tags":["reactjs","javascript","algorithms"],"title":"ES6 Maps are underrated!","uri":"/posts/js-map-vs-array/"},{"categories":["algorithms","frontend"],"content":"Methods of the Map data-structure üìå hashData.clear() // delete all items hashData.forEach((e) =\u003e e.email) // loop for all items hashData.get(\"ggude7\") // search a key, returns the value hashData.has(\"ggude7\") // search a key if its exist as a Boolean hashData.set(\"testUser\", \"user123\") // add a new item with unique key hashData.delete(\"ggude7\") // delete an item with a key hashData.keys() // iterate keys hashData.values() // iterate values hashData.size // returns how many elements it has ","date":"2024-05-22","objectID":"/posts/js-map-vs-array/:5:1","tags":["reactjs","javascript","algorithms"],"title":"ES6 Maps are underrated!","uri":"/posts/js-map-vs-array/"},{"categories":["algorithms","frontend"],"content":"Final Thoughts üí≠ In conclusion, both JavaScript Maps and Arrays have their own strengths and use cases. It‚Äôs important to note that creating a Map in JavaScript can be resource-intensive, so it‚Äôs only worthwhile if you anticipate using find() frequently. JSON as an alternative Alternatively, you can store keys as properties within a JavaScript Object and access values that way. This approach is nearly identical to using a Map, but it has the added benefit of being serializable into JSON. Lastly, when working with JavaScript for front-end development, it‚Äôs worth considering whether excessive focus on performance is a wise decision or not. In my POV, script execution speed rarely becomes the bottleneck for web page or app load times. Rather than vigorously replacing every find() with a Map, consider optimizing your functions \u0026 APIs or refining your UI to enhance the overall user experience. Prioritizing milliseconds of speed improvement in JavaScript code may not always yield noticeable benefits. ","date":"2024-05-22","objectID":"/posts/js-map-vs-array/:6:0","tags":["reactjs","javascript","algorithms"],"title":"ES6 Maps are underrated!","uri":"/posts/js-map-vs-array/"},{"categories":["algorithms","frontend"],"content":"References Grokking Algorithms Linear Search in JS ES6 Map Array.prototype.find Array.prototype.filter Array.prototype.includes ","date":"2024-05-22","objectID":"/posts/js-map-vs-array/:7:0","tags":["reactjs","javascript","algorithms"],"title":"ES6 Maps are underrated!","uri":"/posts/js-map-vs-array/"},{"categories":["frontend","UI"],"content":"In this article, I‚Äôll share some best practices for working with Tailwind CSS, which I usually prefer to follow and have learnt over a period of time. By following these tips, you can keep your application clean, organized, and maintainable, even as your project grows. ","date":"2024-04-23","objectID":"/posts/tailwind-best-practises/:0:0","tags":["tailwind","reactjs"],"title":"How to TailWind CSS like a Pro","uri":"/posts/tailwind-best-practises/"},{"categories":["frontend","UI"],"content":"1. Utilize Design Tokens ü™ô Design tokens are like special containers that hold all the important things that make your designs look good, like colors, sizes, fonts, and where things break on a screen. They help you make sure everything looks the same across all your designs and makes it easy to change things later on. In the tailwind.config.js file, you can create special codes called design tokens. It‚Äôs a smart way to keep all your design codes in one place so that all your special designs can be used by all your different class names in Tailwind CSS. Tailwind Built-in Color Palette Ensure that you assign meaningful semantic names to all the colors used in your project, replacing or extending the default color palette. For multi-theme support, opt to define your colors as CSS variables instead of within your Tailwind configuration. This approach enables you to associate multiple colors with the same semantic name, depending on the selected theme. //\u003c!-- tailwind.config.js --\u003e import defaultTheme from \"tailwindcss/defaultTheme\"; const config = { content: [ \"./src/**/*.{js,ts,jsx,tsx,mdx}\", ], theme: { extend: { fontFamily: { manrope: \"var(--font-manrope)\", }, colors: { ...defaultTheme.colors, theme: \"#7743DB\", light: { primary: \"#FFFFFF\", secondary: \"#f1f1ef\", }, dark: { primary: \"#0F0F0F\", secondary: \"#202020\", }, \"background\": \"#F5F5F5\", }, screens: { ...defaultTheme.screens, xs: \"340px\", sm: \"420px\", }, spacing: { spacing: { ...defaultTheme.spacing, 1: '5px', 2: '10px', 3: '15px', 4: '20px', 5: '25px' } } }, }, }; export default config; ","date":"2024-04-23","objectID":"/posts/tailwind-best-practises/:1:0","tags":["tailwind","reactjs"],"title":"How to TailWind CSS like a Pro","uri":"/posts/tailwind-best-practises/"},{"categories":["frontend","UI"],"content":"2. Make styles reusable üé® Tailwind works best with React, Vue, or Svelte because it helps make components easier to use and reuse. It can still be used with regular HTML, but it might lead to a lot of repeated code. The Tailwind Docs suggest using a special editing technique to avoid this, but it can be tricky and you have to be careful to select all the right parts. With a component-based framework like React, you can create a part of your website once and use it many times in different places. // Define a reusable Button component using Tailwind utility classes const Button = ({ children, onClick }) =\u003e { return ( \u003cbutton onClick={onClick} className=\"bg-primary hover:bg-primary-alt text-primary-contrast py-2 px-4 rounded\" \u003e {children} \u003c/button\u003e ); }; // Use (and re-use) the Button component without having to duplicate Tailwind classes const App = () =\u003e { return ( \u003cdiv\u003e \u003cButton onClick={() =\u003e console.log('Clicked!')}\u003eClick Me\u003c/Button\u003e \u003cButton onClick={() =\u003e console.log('Clicked too!')}\u003eClick Me Too\u003c/Button\u003e \u003c/div\u003e ); }; ","date":"2024-04-23","objectID":"/posts/tailwind-best-practises/:2:0","tags":["tailwind","reactjs"],"title":"How to TailWind CSS like a Pro","uri":"/posts/tailwind-best-practises/"},{"categories":["frontend","UI"],"content":"3. Use arbitrary values rarely üôÖ‚Äç‚ôÄÔ∏è Consider a web application that adheres to a specific color scheme. For instance, we‚Äôve chosen #7743DB as our theme color and #0D0D0D as our background color. To maintain consistency and improve readability, we can add these colors to our Tailwind CSS configuration. Instead of using arbitrary values directly in our HTML or CSS, we‚Äôll create semantic class names. For example: bg-background for the background color text-theme for the theme color //\u003c!-- tailwind.config.js --\u003e import defaultTheme from \"tailwindcss/defaultTheme\"; const config = { content: [ \"./src/**/*.{js,ts,jsx,tsx,mdx}\", ], theme: { extend: { colors: { ...defaultTheme.colors, theme: \"#7743DB\", background: \"#0D0D0D\" }, }, }, }; export default config; Now, if we decide to change our application‚Äôs color scheme, we only need to update the tailwind.config.js file. This approach avoids the hassle of renaming arbitrary class names scattered throughout our codebase. ","date":"2024-04-23","objectID":"/posts/tailwind-best-practises/:3:0","tags":["tailwind","reactjs"],"title":"How to TailWind CSS like a Pro","uri":"/posts/tailwind-best-practises/"},{"categories":["frontend","UI"],"content":"4. Handle dynamic classes with care üßê You all might have encountered this issue while working with dynamic classes that whenever we apply some dynamic class name based on state or some condition, the class name appears in elements panel on the browser, but its corresponding CSS does not. This is because Tailwind scans your source code for classes using regular expressions to extract every string that could possibly be a class name. He nce, any broken class name string such as border-[${borderColor}] would not be recognised by tailwind at build time, and it would not be included in the output CSS file of tailwind. Suppose, we have to change the border colour of our element based on the colour code passed in props. There are two ways to it: Defining a separate class name for each state value. This is only applicable if you know all the expected values of the borderColor at build time. Note: clsx is utility package for constructing className strings conditionally. //\u003c!-- BorderBox.jsx --\u003e const BorderBox = ({ borderColor }) =\u003e { return ( \u003cdiv className={clsx(\"border border-solid\", { \"border-black\": borderColor === \"black\", \"border-red-500\": borderColor === \"red\", \"border-green-500\": borderColor === \"green\", })} \u003e Some Random Text \u003c/div\u003e ); }; 2. If we do not know all the expected value of borderColor at build time, it is better to pass the border colour in the style attribute of the element to support unknown values. //\u003c!-- BorderBox.jsx --\u003e const BorderBox = ({ borderColor }) =\u003e { return ( \u003cdiv className=\"border border-solid\" style={{ borderColor }}\u003e Some Random Text \u003c/div\u003e ); }; ","date":"2024-04-23","objectID":"/posts/tailwind-best-practises/:4:0","tags":["tailwind","reactjs"],"title":"How to TailWind CSS like a Pro","uri":"/posts/tailwind-best-practises/"},{"categories":["frontend","UI"],"content":"5. Accessing CSS design tokens in JavaScript üß≤ In Web applications, there are multiple scenarios where you need to access a CSS design token value in JavaScript. When such situations arise, developers often hardcode the CSS design token directly into their code while working with Tailwind CSS. However, this practice is not ideal. If you later modify the design token value in your Tailwind configuration, your code might still reference the old value, potentially leading to unintended behavior. To address this, consider creating a custom utility function that reads the Tailwind configuration dynamically within your codebase. //\u003c!-- tailwind.config.js --\u003e import resolveConfig from \"tailwindcss/resolveConfig\"; import tailwindConfig from \"../tailwind.config\"; const getTailwindConfiguration = () =\u003e { return resolveConfig(tailwindConfig).theme; }; const config = getTailwindConfiguration(); console.log(config.colors.red[500]); // would print #ef4444 ","date":"2024-04-23","objectID":"/posts/tailwind-best-practises/:5:0","tags":["tailwind","reactjs"],"title":"How to TailWind CSS like a Pro","uri":"/posts/tailwind-best-practises/"},{"categories":["frontend","UI"],"content":"6. Tailwind Plugins üß© Tailwind provides us with plugins to register new styles to inject into the user‚Äôs stylesheet using JavaScript instead of writing custom CSS styling in stylesheets. I find this approach better, as writing custom CSS classes means you‚Äôre essentially rewriting CSS and waving goodbye to Tailwind‚Äôs organized workflow and simple maintenance. Suppose we want to create a .header class which has several styles attached to it. This is how we can achieve it: //\u003c!-- tailwind.config.js --\u003e import plugin from \"tailwindcss/plugin\"; const config = { content: [ \"./src/**/*.{js,ts,jsx,tsx,mdx}\", ], plugins: [ plugin(function ({ addComponents }) { addComponents({ \".header\": { fontWeight: \"600\", height: \"3rem\", borderRadius: \".25rem\", backgroundColor: \"#f5f5f5\", boxShadow: \"0 2px 4px 0 rgba(0,0,0,.1)\", display: \"flex\", justifyContent: \"space-between\", alignItems: \"center\", \"\u0026:hover\": { backgroundColor: \"#f5f5f5\", }, }, }); }), ], }; export default config; This is how the .header class would look like when you hover over it: Custom Tailwind Plugin for Complex styles ","date":"2024-04-23","objectID":"/posts/tailwind-best-practises/:6:0","tags":["tailwind","reactjs"],"title":"How to TailWind CSS like a Pro","uri":"/posts/tailwind-best-practises/"},{"categories":["frontend","UI"],"content":"Final Words üé§ While Tailwind CSS provides a strong and versatile utility-first approach to styling web apps, it‚Äôs important to avoid common errors that can jeopardize the maintainability and scalability of your code. By carefully integrating Tailwind with a uniform design system, embracing component-based architecture, and establishing a library of reusable components, you can create clean, consistent, and highly maintainable user interfaces. ","date":"2024-04-23","objectID":"/posts/tailwind-best-practises/:7:0","tags":["tailwind","reactjs"],"title":"How to TailWind CSS like a Pro","uri":"/posts/tailwind-best-practises/"},{"categories":["UI","UX"],"content":"The Need for a Robust UI Component Library As our web application grew in complexity, we found ourselves constantly reinventing the wheel when it came to building user interfaces. Our development team was spending too much time creating and maintaining custom UI components, leading to inconsistent styles, duplicated code, and a suboptimal developer experience. To address these challenges, we decided to invest in building a comprehensive UI component library that would serve as the foundation for our application‚Äôs user interface. Our goal was to create a modular and scalable system that would not only improve the efficiency of our development process but also ensure a cohesive and visually appealing user experience. ","date":"2024-04-05","objectID":"/posts/ui-components/:1:0","tags":["tailwind","css","storybook","react"],"title":"Intuji UI Components ‚ôæÔ∏è","uri":"/posts/ui-components/"},{"categories":["UI","UX"],"content":"Embracing Tailwind CSS for Consistent Styling After careful consideration, we chose to build our component library using Tailwind CSS, a utility-first CSS framework that has gained immense popularity in the front-end development community. Tailwind CSS provides a vast collection of low-level utility classes that can be easily composed to create complex designs, allowing us to achieve a high degree of customization and consistency across our components. By leveraging Tailwind CSS, we were able to establish a robust design system that seamlessly integrates with our application‚Äôs branding and UI guidelines. The utility-first approach of Tailwind CSS empowers our developers to quickly prototype and iterate on component designs, without the need to write extensive custom CSS. ","date":"2024-04-05","objectID":"/posts/ui-components/:2:0","tags":["tailwind","css","storybook","react"],"title":"Intuji UI Components ‚ôæÔ∏è","uri":"/posts/ui-components/"},{"categories":["UI","UX"],"content":"Integrating TypeScript for Enhanced Developer Experience To ensure type safety and improve the overall developer experience, we decided to implement our component library using TypeScript. By embracing the static typing capabilities of TypeScript, we were able to catch potential errors during development, leading to more reliable and maintainable code. The TypeScript integration also allowed us to provide detailed type definitions for our components, making it easier for other developers to understand and use the library. This, in turn, helped to reduce the learning curve and improved the overall developer productivity within our team. ","date":"2024-04-05","objectID":"/posts/ui-components/:3:0","tags":["tailwind","css","storybook","react"],"title":"Intuji UI Components ‚ôæÔ∏è","uri":"/posts/ui-components/"},{"categories":["UI","UX"],"content":"Leveraging Storybook for Isolated Component Development To facilitate the development, documentation, and testing of our UI components, we integrated Storybook into our workflow. Storybook is a powerful tool that enables us to build UI components in isolation, without the interference of the actual application‚Äôs state or dependencies. By using Storybook, our developers can focus on creating and refining individual components, ensuring that they adhere to the design guidelines and are thoroughly tested. Additionally, Storybook‚Äôs rich feature set, including the ability to generate interactive documentation and facilitate visual regression testing, has been invaluable in streamlining our component development process. ","date":"2024-04-05","objectID":"/posts/ui-components/:4:0","tags":["tailwind","css","storybook","react"],"title":"Intuji UI Components ‚ôæÔ∏è","uri":"/posts/ui-components/"},{"categories":["UI","UX"],"content":"Ensuring Reliability with Vitest To maintain the quality and stability of our UI component library, we‚Äôve implemented a comprehensive testing suite using Vitest, a modern and lightning-fast testing framework. Vitest allows us to write unit tests for our components, ensuring that they behave as expected and continue to function correctly as the library evolves. The integration of Vitest has been instrumental in catching regressions early in the development cycle, reducing the risk of introducing breaking changes and ensuring a reliable user experience for our application‚Äôs end-users. ","date":"2024-04-05","objectID":"/posts/ui-components/:5:0","tags":["tailwind","css","storybook","react"],"title":"Intuji UI Components ‚ôæÔ∏è","uri":"/posts/ui-components/"},{"categories":["UI","UX"],"content":"Continuous Improvement and Expansion As we continue to build and maintain our UI component library, we‚Äôre committed to an iterative approach that prioritizes user feedback, emerging front-end trends, and the evolving needs of our application. We‚Äôll regularly review the library‚Äôs design, APIs, and documentation, making adjustments and additions as necessary to keep it up-to-date and aligned with the project‚Äôs requirements. By leveraging Tailwind CSS, TypeScript, Storybook, and Vitest, we‚Äôve laid a strong foundation for a scalable and maintainable UI component library that will empower our development team to build high-quality user interfaces more efficiently. We‚Äôre excited to see how this library will continue to evolve and support the growth of our application in the months and years to come. Final Words The Intuji UI component library is an ongoing project, and we‚Äôre committed to its continuous improvement and expansion. As our application‚Äôs needs evolve and as we gather feedback from our users, we‚Äôll be regularly updating and enhancing the library to ensure it remains a reliable and cutting-edge resource for our development team. This blog post itself will also be updated over time to reflect the latest developments, new features, and improvements made to the Intuji component library. Be sure to check back periodically for the most up-to-date information and insights. We‚Äôre excited to see how the Intuji library will continue to grow and support the success of our application. Thank you for your interest, and we look forward to sharing more updates with you in the future. Hyperlinks Github Repo: Intuji UI Components Documentation Site: Intuji UI Components ","date":"2024-04-05","objectID":"/posts/ui-components/:6:0","tags":["tailwind","css","storybook","react"],"title":"Intuji UI Components ‚ôæÔ∏è","uri":"/posts/ui-components/"},{"categories":["UI","UX"],"content":"Content loaders, skeleton screens, ghost elements, and content placeholders. These are the names given to the effect we‚Äôll be exploring today. Many companies, such as LinkedIn, Facebook, YouTube and Slack, use this effect in their apps and websites, as you may have noticed. As much as we developers want our websites to load as quickly as possible, there are times when a lot of data needs to be rendered on the page, so Skeleton screens are a great option. CSS technology used Although some of the above mentioned sites use Vanilla CSS and other CSS libs/frameworks to achieve the effect, I have used the latest version of Tailwind CSS (v3.1.5) as of date to create it. Developers earlier used to add a loading spinner animation to indicate that the page resources are still being fetched in the background which doesn‚Äôt fit the UI/UX standards of the current timeline. Classic Loading Spinner Animation This boring spinner animation would definitely result a lower score in User Experience Web Index. ","date":"2022-07-03","objectID":"/posts/tailwind-skeleton/:0:0","tags":["tailwind","css"],"title":"‚ú®Shiny Skeleton Animation using TailwindCSSüí®","uri":"/posts/tailwind-skeleton/"},{"categories":["UI","UX"],"content":" Animated skeleton example I grabbed from some random site ","date":"2022-07-03","objectID":"/posts/tailwind-skeleton/:1:0","tags":["tailwind","css"],"title":"‚ú®Shiny Skeleton Animation using TailwindCSSüí®","uri":"/posts/tailwind-skeleton/"},{"categories":["UI","UX"],"content":"Building a Skeleton Block ü¶¥ First of all, lets use Tailwind‚Äôs range of utility classes to create a skeleton that roughly resembles the content you‚Äôre about to load. I have created a simple block to denote a member of our skeleton animation which may(not) scale throughout the viewport. Size Limit For demonstration purposes I have limited the wrapper width to 200px. If you were to increase the dimension, you would have to update the CSS props accordingly. \u003cdiv class=\"flex min-h-screen items-center justify-center bg-gray-900\"\u003e \u003cdiv class=\"w-[200px]\"\u003e \u003cdiv class=\"space-y-5 rounded-2xl bg-white/5 p-4 shadow-xl shadow-black/5\"\u003e \u003cdiv class=\"h-24 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"space-y-3\"\u003e \u003cdiv class=\"h-3 w-3/5 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-4/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-2/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e ","date":"2022-07-03","objectID":"/posts/tailwind-skeleton/:2:0","tags":["tailwind","css"],"title":"‚ú®Shiny Skeleton Animation using TailwindCSSüí®","uri":"/posts/tailwind-skeleton/"},{"categories":["UI","UX"],"content":"Linear Gradient Overlay üåä I have to admit that I don‚Äôt cross paths often with Linear Gradients on my day-to-day work. However with enough effort I was able to use Tailwind‚Äôs gradient color stops to create a gradient that fades from transparent to white and back to transparent. \u003cdiv class=\"flex min-h-screen items-center justify-center bg-gray-900\"\u003e \u003cdiv class=\"w-[200px]\"\u003e \u003cdiv class=\"h-48 bg-gradient-to-r from-transparent via-rose-100/20 to-transparent\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e ","date":"2022-07-03","objectID":"/posts/tailwind-skeleton/:3:0","tags":["tailwind","css"],"title":"‚ú®Shiny Skeleton Animation using TailwindCSSüí®","uri":"/posts/tailwind-skeleton/"},{"categories":["UI","UX"],"content":"Keyframe Animation üé≠ Lets define a CSS keyframe animation that translates elements 100% to the right in the extend keyframes object of tailwind.config.js. I have used Tailwind‚Äôs arbitrary values to apply the keyframe animation to the overlay element. I have added a custom keyframe shift by the name of shimmer as well as curated my own color named stone from the Tailwind‚Äôs default color palette by importing tailwindcss/colors. tailwind.config.js const colors = require('tailwindcss/colors') module.exports = { theme: { extend: { colors: { gray: colors.stone, }, }, keyframes: { shimmer: { '100%': { transform: 'translateX(100%)', }, }, }, }, plugins: [], } \u003cdiv class=\"flex min-h-screen items-center justify-center bg-gray-900\"\u003e \u003cdiv class=\"w-[200px]\"\u003e \u003cdiv class=\"h-48 -translate-x-full animate-[shimmer_2s_infinite] bg-gradient-to-r from-transparent via-rose-100/20 to-transparent\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e ","date":"2022-07-03","objectID":"/posts/tailwind-skeleton/:4:0","tags":["tailwind","css"],"title":"‚ú®Shiny Skeleton Animation using TailwindCSSüí®","uri":"/posts/tailwind-skeleton/"},{"categories":["UI","UX"],"content":"Mixing the Elements ü•¢ Now we shall combine our skeleton block with the overlay animation by adding the overlay to a pseudo-element of the skeleton wrapper using Tailwind‚Äôs before: modifier. \u003cdiv class=\"flex min-h-screen items-center justify-center bg-gray-900\"\u003e \u003cdiv class=\"w-[200px]\"\u003e \u003cdiv class=\"relative space-y-5 rounded-2xl bg-white/5 p-4 shadow-xl shadow-black/5 before:absolute before:inset-0 before:-translate-x-full before:animate-[shimmer_2s_infinite] before:bg-gradient-to-r before:from-transparent before:via-rose-100/10 before:to-transparent\"\u003e \u003cdiv class=\"h-24 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"space-y-3\"\u003e \u003cdiv class=\"h-3 w-3/5 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-4/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-2/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e ","date":"2022-07-03","objectID":"/posts/tailwind-skeleton/:5:0","tags":["tailwind","css"],"title":"‚ú®Shiny Skeleton Animation using TailwindCSSüí®","uri":"/posts/tailwind-skeleton/"},{"categories":["UI","UX"],"content":"Finishing Touches üé® To make our overlay animation sharper I tried hiding the overlay while it‚Äôs positioned outside the skeleton. This limits the overlay overflow within the skeleton‚Äôs block and gives our effect a sharper look. Optional Add a white border to the top of the overlay to simulate light reflecting on the top of the skeleton. \u003cdiv class=\"flex min-h-screen items-center justify-center bg-gray-900\"\u003e \u003cdiv class=\"w-[200px]\"\u003e \u003cdiv class=\"relative space-y-5 overflow-hidden rounded-2xl bg-white/5 p-4 shadow-xl shadow-black/5 before:absolute before:inset-0 before:-translate-x-full before:animate-[shimmer_2s_infinite] before:border-t before:border-rose-100/10 before:bg-gradient-to-r before:from-transparent before:via-rose-100/10 before:to-transparent\"\u003e \u003cdiv class=\"h-24 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"space-y-3\"\u003e \u003cdiv class=\"h-3 w-3/5 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-4/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-2/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e ","date":"2022-07-03","objectID":"/posts/tailwind-skeleton/:6:0","tags":["tailwind","css"],"title":"‚ú®Shiny Skeleton Animation using TailwindCSSüí®","uri":"/posts/tailwind-skeleton/"},{"categories":["UI","UX"],"content":"Final Words üéô Therefore, using powerful Tailwind CSS‚Äôs utility classes, we can build a complex customized layout to place our animated skeleton such as grid, flexbox, etc. Below is a simple grid layout with our fancy skeleton boxes. Here is the link to the Live Tailwind Playground to play around with our final build. \u003cdiv class=\"flex min-h-screen items-center justify-center bg-gray-900\"\u003e \u003cdiv class=\"grid w-[600px] grid-cols-3 gap-6\"\u003e \u003c!-- First Card Begins Here --\u003e \u003cdiv class=\"relative space-y-5 overflow-hidden rounded-2xl bg-white/5 p-4 shadow-xl shadow-black/5 before:absolute before:inset-0 before:-translate-x-full before:animate-[shimmer_2s_infinite] before:border-t before:border-rose-100/10 before:bg-gradient-to-r before:from-transparent before:via-rose-100/10 before:to-transparent\"\u003e \u003cdiv class=\"h-24 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"space-y-3\"\u003e \u003cdiv class=\"h-3 w-3/5 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-4/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-2/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c!-- First Card Ends Here --\u003e \u003c!--Second Card Begins Here --\u003e \u003cdiv class=\"relative space-y-5 overflow-hidden rounded-2xl bg-white/5 p-4 shadow-xl shadow-black/5 before:absolute before:inset-0 before:-translate-x-full before:animate-[shimmer_2s_infinite] before:border-t before:border-rose-100/10 before:bg-gradient-to-r before:from-transparent before:via-rose-100/10 before:to-transparent\"\u003e \u003cdiv class=\"h-24 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"space-y-3\"\u003e \u003cdiv class=\"h-3 w-3/5 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-4/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-2/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c!-- Second Card Ends Here --\u003e \u003c!-- Third Card Begins Here --\u003e \u003cdiv class=\"relative space-y-5 overflow-hidden rounded-2xl bg-white/5 p-4 shadow-xl shadow-black/5 before:absolute before:inset-0 before:-translate-x-full before:animate-[shimmer_2s_infinite] before:border-t before:border-rose-100/10 before:bg-gradient-to-r before:from-transparent before:via-rose-100/10 before:to-transparent\"\u003e \u003cdiv class=\"h-24 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"space-y-3\"\u003e \u003cdiv class=\"h-3 w-3/5 rounded-lg bg-rose-100/10\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-4/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003cdiv class=\"h-3 w-2/5 rounded-lg bg-rose-100/20\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c!-- Third Card Ends Here --\u003e \u003c/div\u003e \u003c/div\u003e I hope you found this article useful and that it serves as a good starting point (not only for developers but also for Designers) for creating various skeleton loading screens. If you found this article insightful, do share it with your friends and network. Before you leave üìå Do check out some amazing skeleton loading packages I have found for React, Angular and Vue. Thanks for reading, and keep creating amazing UI with Tailwindüí®! ","date":"2022-07-03","objectID":"/posts/tailwind-skeleton/:7:0","tags":["tailwind","css"],"title":"‚ú®Shiny Skeleton Animation using TailwindCSSüí®","uri":"/posts/tailwind-skeleton/"}]